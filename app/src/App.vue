<script>
import { toBytes } from 'fast-base64'
import { saveAs } from 'file-saver'

const API_ENDPOINT = 'https://papermaker.labs.zikani.me/api/v1/generate'
// const API_ENDPOINT = 'http://localhost:7765/api/v1/generate'

const QUESTION_TYPE = {
    MULTIPLE_CHOICE: 1,
    FREEFORM: 2,
    LABEL_DIAGRAM: 3
  };
  
  let Question = function(titleText, questionType, options = {}) {
    this.title = titleText;
    this.content = content;
    this. questionType = questionType;
    // question belongs to specific section
    if (options.section) {
      this.sectionID = options.section
    }
    if (this.questionType === QUESTION_TYPE.MULTIPLE_CHOICE) {
      this.answerOptions = options.answerOptions || []
    }
    if (this.questionType === QUESTION_TYPE.FREEFORM) {
      this.lineOptions = options.lines || 3
    }
  }
  
function fallbackAPIBackedGeneratePaper(data, outputFormat)  {
  return fetch(API_ENDPOINT, {
      method: 'POST',
      body: JSON.stringify(data),
    })
    .then(response => {
      if (response.ok) {
        return response.text()
      }
      return response.text().then(txt => {
        let err = new Error('Failed to process request')
        if (txt.indexOf('validationErrors') > 0) {
          err.data = JSON.parse(txt)
        }
        return Promise.reject(err)
      })
    })
}

function resetNewQuestion() {
  let newQuestionData = {
    id: '',
    title: '',
    content: '',
    questionType: '',
    numAnswerOptions: 4,
    answerOptions: [],
  };

  for(var i = 0; i < newQuestionData.numAnswerOptions; i++) {
    newQuestionData.answerOptions.push({ id: i, idx: i, content: '', })
  }
  return newQuestionData;
}
  
export default {
    // template: document.getElementById('app-template').innerHTML,
    components: {
      // "NewQuestionComponent": NewQuestionComponent,
    },
    data() {
      return {
        appTitle: 'Paper Maker App',
        activeTabName: 'newPaperTab',
        title: '',
        classTerm: '',
        className: '',
        schoolName: '',
        subjectName: '',
        selectedExamType: null,
        selectedExamTypeModel: 'free_form',
        outputFormat: "docx",
        examDate: '',
        timeAllowed: '',
        teacherName: '',
        questions: [],
        sections: [],
        columnCount: 1,
        currentQuestionIdx: -1,
        // transient variable to store in process question.
        newSection: {
          id: '',
          name: '',
          displaySectionName: true,
        },
        newQuestion: resetNewQuestion(),
        downloadedData: null,
        outputName: '',        
        // UI stuff
        useOfflineMode: true,
        isEditingQuestion: false,
        isEditingSection: false,
        hasMultipleSections: false,
        generating: false,
        paperGenerated: false,
        isWasmModuleLoaded: false,
        examTypeColumns: [
          { value: "free_form", text: "Free Form" },
          { value: "multiple_choice", text: "Multiple Choice" },
          { value: "mixed", text: "Mixed" },
        ],
        showExamOptionsPicker: false,
        uncollapsedQuestions: [],
        uncollaps: [],
      }
    },
  
    computed: {

      computedTitle() {
        if (this.title.length > 0) {
          return this.title
        }
        return `${this.subjectName} - ${this.classTerm}`
      },

      newQuestionIsMultipleChoice() {
        return this.newQuestion.questionType == "multiple_choice"
      },

      isFreeFormSupported() {
        return this.selectedExamTypeModel && (this.selectedExamTypeModel == 'free_form' || this.selectedExamTypeModel == 'mixed');
      },

      isMultipleChoiceSupported() {
        return this.selectedExamTypeModel && (this.selectedExamTypeModel == 'multiple_choice' || this.selectedExamTypeModel == 'mixed');
      },

      hasSections() {
        return this.sections.length > 0;
      },

      availableSections() {
        return [];//TODO: SECTIONS
      },
      noOfQuestions() {
        return  this.questions ? this.questions.length : 0;
      },
  
      nextQuestionIdx() {
        if (this.currentQuestionIdx == -1) {
          return 0
        }
        if ((this.currentQuestionIdx + 1 ) > this.questions.length - 1) {
          return questions.length
        }
        return this.currentQuestionIdx + 1;
      },
      
      paperFilename() {
        let normalizedTitle = `${this.subjectName} - ${this.classTerm}`
        normalizedTitle = normalizedTitle.replace('\s\\\\//\*!#$%', '')
        return `${normalizedTitle} [Generated by Paper Maker App labs.zikani.me].${this.outputFormat}`
      },

      downloadedDataBase64URL() {
        return this.downloadedData;
      }
    },
  
    methods: {      

      multipleChoiceLabel(idx, type = "alphabet") {
        if (type === "alphabet")
          return ["A","B","C","D","E","F","G","H","I"][idx] + ") ";
          if (type === "numeric") 
            return `${idx}. `;
          if (type === "numeric_roman") 
            return ["i","ii","iii","iv","v","vi","vii","viii","viiii"][idx] + ") ";
      },

      resetNewQuestion() {
        this.newQuestion = resetNewQuestion()
      },

      prevQuestion() {
        if (this.currentQuestionIdx > 0) {
          this.currentQuestionIdx -= 1
        }
      },
  
      nextQuestion() {
        this.currentQuestionIdx += 1
        if (this.currentQuestionIdx > this.questions.length - 1) {
          this.currentQuestionIdx = questions.length - 1;
        }
      },

      onExamOptionSelected(selectedItem) {
        this.selectedExamType = selectedItem
        this.showExamOptionsPicker = false
      },

      saveOrEditSection(event) {
        let sectionData = Object.assign({}, this.newSection, { id: this.sections.length + 1 })
        this.sections.push(sectionData)
        this.isEditingSection = false
      },

      saveOrEditQuestion(event) {
        if (this.newQuestion.content.length < 1) {
          return;
        }
        let questionData = Object.assign({}, this.newQuestion)
        // TODO: handle answer options for multiple choice
        this.questions.push(questionData)
        this.resetNewQuestion()
        this.isEditingQuestion = false
      },

      generatePaper(data, outputFormat) {
        if (this.useOfflineMode) {
          let result = GeneratePaper(JSON.stringify(data), outputFormat)
          if (result.indexOf('base64') > 0) {
            return Promise.resolve(result)
          }
          let err = new Error('Failed to process request: ' + result)
          if (result.indexOf('validationErrors') > 0) {
            err.data = JSON.parse(result)
          }
          return Promise.reject(err)
        }
        return fallbackAPIBackedGeneratePaper(data, outputFormat)
      },
  
      submitGenerate(event) {
        event.preventDefault()
  
        const data = {
          outputFormat: this.outputFormat,
          title: this.computedTitle,
          className: this.className,
          schoolName: this.schoolName,
          teacherName: this.teacherName,
          subjectName: this.subjectName,
          isDoubleColumn: this.isDoubleColumn,
          timeAllowed: this.timeAllowed,
          examDate: this.examDate,
          questions: this.questions.map((q, idx) => {
            return {
              sortOrder: idx + 1,

              section: q.section,
              title: q.title,
              content: q.content,
              questionType:  q.questionType,

              answerOptions: q.answerOptions.map(opt => {
                return {
                  content: opt.content,
                  isCorrect: opt.isCorrect,
                }
              }),
              
              image: {
                url: "",
                width: "",
                height: "",
                alt: "Figure 1"
              }
            }
          }),
          font: {
            name: this.fontName,
            size: this.fontSize,
            file: "", // TODO
          },
        }
  
        this.generating = true;
        this.paperGenerated = false;

        this.generatePaper(data, this.outputFormat)
        .then(paperBase64Encoded => {
          this.downloadedData = paperBase64Encoded
          this.paperGenerated = true;
          this.generating = false;
          let justData = paperBase64Encoded.replace('data:application/msword;base64,', '');
          toBytes(justData).then(byteData => {
            var dataBlob = new Blob([byteData], {type: "data:application/octet-stream"});
            saveAs(dataBlob, this.paperFilename);
          })

          this.$notify({ type: 'success', message: 'Process completed sucessfully, download will start automatically...' });
        })
        .catch(err => {
          if (err['data']) {
            let data = err['data'];
            let errors  = data['validationErrors'] || ['unknown errors'];

            this.$notify({ 
              type: 'warning', 
              message: '⚠️ Validation errors: ' + errors.join('× ') 
            });
            return;
          }

          this.$notify({ 
            type: 'warning', 
            message: 'Failed to process request. error: ' + err 
          });
        })

        return false;
      }
    }
  
  }
</script>

<template>
    <van-nav-bar
      :title="appTitle"
    />
    <van-tabs v-model:active="activeTabName">
      <van-tab title="New Paper" name="newPaperTab">

        <van-cell-group inset>
          <van-field
            v-model="subjectName"
            name="subjectName"
            label="Subject"
            placeholder="Subject"
            :rules="[{ required: true, message: 'Subject is required' }]"
          />

          <van-field
            v-model="classTerm"
            name="classTerm"
            label="Term or Year"
            placeholder="Term or Year"
            :rules="[{ required: true, message: 'Term or Year is required' }]"
          />

          <van-field
            v-model="className"
            name="className"
            label="Class Name"
            placeholder="Class Name"
            :rules="[{ required: true, message: 'Class is required' }]"
          />
          <van-field
            v-model="teacherName"
            name="teacherName"
            label="Teacher Name"
            placeholder="Teacher Name"
            :rules="[{ required: true, message: 'Teacher Name is required' }]"
          />
          <van-field
            v-model="schoolName"
            name="schoolName"
            label="School Name"
            placeholder="School Name"
            :rules="[{ required: true, message: 'School Name is required' }]"
          />
          <van-field
            v-model="timeAllowed"
            name="timeAllowed"
            label="Time Allowed"
            placeholder="e.g. 2.5 Hours"
            :rules="[{ required: true, message: 'Time Allowed is required' }]"
          />
          <van-field
            v-model="examDate"
            name="examDate"
            label="Exam Date"
            placeholder="e.g. 30 / 12 / 2022"
            :rules="[{ required: true, message: 'Exam Date is required' }]"
          />

          <van-field name="radio" label="Type">
            <template #input>
              <van-radio-group v-model="selectedExamTypeModel" direction="horizontal">
                <van-radio v-for="e in examTypeColumns" :name="e.value">{{ e.text }}</van-radio>
              </van-radio-group>
            </template>
          </van-field>

          <!-- <van-checkbox v-model="hasMultipleSections">Has Multiple Sections?</van-checkbox> -->

          <van-divider v-show="hasMultipleSections">Sections</van-divider>

          <van-cell-group v-show="hasMultipleSections">
            <van-button type="primary" round size="mini" class="bottom-button"  @click="isEditingSection = true">Add a new section</van-button>
            <van-empty v-if="!hasSections" image="error" description="No sections created.">
              <van-button type="primary" round size="mini" class="bottom-button"  @click="isEditingSection = true">Click here to add a new section</van-button>
            </van-empty>  
            <van-list v-else>
              <van-cell v-for="s in sections" :key="s.id" :title="'Section: ' + s.name" />
            </van-list>
          </van-cell-group>

          <van-divider>Questions</van-divider>
          
          <van-button type="primary" round size="mini" @click="isEditingQuestion = true">Add New Question</van-button>

          <div v-if="questions.length < 1">
            <van-empty image="error" description="No questions created.">
              <span style="color: royalblue; cursor: pointer;" @click="isEditingQuestion = true">Click here to add a new question</span>
            </van-empty>
          </div>
          <van-collapse v-model="uncollapsedQuestions" v-else>
            <van-collapse-item :title="(idx + 1)  + '. ' + q.content" v-for="(q, idx) in questions" :key="q.id">
              <article>
                <div class="question-content">{{idx}}. {{ q.content }}</div>
              </article>
            </van-collapse-item>
          </van-collapse>
          <!-- TODO: implement advanced settings  -->
          <!-- <van-divider>Advanced Settings</van-divider> -->
          <!-- <van-field
            v-model="outputName"
            name="outputName"
            label="File Name"
            :placeholder="title + '.docx' "
            :rules="[{ required: true, message: 'File Name is required' }]"
          /> -->

          <!-- <van-field name="radio" label="Columns">
            <template #input>
              <van-radio-group v-model="columnCount" direction="horizontal">
                <van-radio name="1">Single Column</van-radio>
                <van-radio name="2">Double Column</van-radio>
              </van-radio-group>
            </template>
          </van-field> -->

          <div>
            
            <div v-show="paperGenerated" style="padding: 0.3em;">
              <small>
                <a :href="this.downloadedDataBase64URL" ref="downloadEl" :download="paperFilename">Click here</a>&nbsp; if download does not start automatically
              </small>
            </div>

            <van-button type="primary" round block @click.prevent="submitGenerate">Generate Exam Paper (.docx)</van-button>

          </div>
        </van-cell-group> 



      </van-tab>
      <!-- <van-tab title="Your Papers" name="a">content of tab 1</van-tab> -->
      <van-tab title="About" name="aboutTab">
        <About />
      </van-tab>
    </van-tabs>

    <van-popup
      v-model:show="isEditingQuestion"
      closeable
      position="bottom"
      :style="{ height: '70%' }"
    >
      <h4>Create a Question</h4>

      <van-field name="radio" label="Type">
        <template #input>
          <van-radio-group v-model="newQuestion.questionType" direction="horizontal">
            <van-radio name="multiple_choice" :disabled="!isMultipleChoiceSupported">Multiple Choice</van-radio>
            <van-radio name="free_form" :disabled="!isFreeFormSupported">Free Form</van-radio>
          </van-radio-group>
        </template>
      </van-field>

      <van-field
          v-model="newQuestion.content"
          name="questionContent"
          label="Question"
          placeholder="Type the question here"
          :rules="[{ required: true, message: 'Question Content is required' }]"
        />

        <van-cell-group v-show="newQuestionIsMultipleChoice">
          <h5>Multiple Choice Answers</h5>      
          <van-button type="primary" size="mini" @click="newQuestion.numAnswerOptions++">Add another answer</van-button>

          <van-cell-group>
            <van-field
            v-for="opt of newQuestion.answerOptions"
            v-model="opt.content"
              :key="opt.id"
              name="answerOption1"
              :label="multipleChoiceLabel(opt.idx)"
              placeholder="Type answer"
              :rules="[{ required: true, message: 'Answer options is required' }]"
            />


          </van-cell-group>

        </van-cell-group>

      <van-button type="primary" round block @click="saveOrEditQuestion">Add Question</van-button>
    </van-popup>

    <van-popup
      v-model:show="isEditingSection"
      closeable
      position="bottom"
      :style="{ height: '30%' }"
    >
        <van-field
        v-model="newSection.name"
        name="sectionName"
        label="Section Name"
        placeholder="Section Name"
        :rules="[{ required: true, message: 'Section Name is required' }]"
      />
      <van-button type="primary" round block @click="saveOrEditSection">Add Section</van-button>
    </van-popup>
</template>

<style scoped>
</style>
